# Отчет Лебедев Андрей Андреевич БПИ234

## Вариант 21

**Задача о нелюдимых садовниках**. Имеется пустой участок
земли (двумерный массив размером M ×N) и план сада, разбитого
на отдельные квадраты. От 10 до 30 процентов (задается случайно) площади сада заняты прудами или камнями. То есть недоступны для ухаживания. Эти квадраты располагаются на плане произвольным (случайным) образом. Ухаживание за садом выполняют два садовника, которые не хотят встречаться друг другом (то
есть, одновременно появляться в одном и том же квадрате). Первый садовник начинает работу с верхнего левого угла сада и перемещается слева направо, сделав ряд, он спускается вниз и идет в
обратном направлении, пропуская обработанные участки. Второй
садовник начинает работу с нижнего правого угла сада и перемещается снизу вверх, сделав ряд, он перемещается влево и также
идет в обратную сторону. Если садовник видит, что участок сада
уже обработан другим садовником или является необрабатывае18
мым, он идет дальше. Если по пути какой-то участок занят другим садовником, то садовник ожидает когда участок освободится,
чтобы пройти дальше на доступный ему необработанный участок.
Садовники должны работать одновременно со скоростями, определяемыми как параметры задачи. Прохождение через любой
квадрат занимает некоторое время, которое задается константой,
меньшей чем времена обработки и принимается за единицу времени

## 4-5

### Описание сущностей

-   **Сад**: Представлен двумерной сеткой `grid[M][N]` на сервере, где каждая клетка имеет:
    -   `type` (0: недоступна, 1: доступна);
    -   `processed_by` (0: необработана, 1: обработана садовником 1, 2: обработана садовником 2);
    -   `occupied_by` (0: свободна, 1: занята садовником 1, 2: занята садовником 2).
-   **Садовники**: Два клиента, каждый с уникальным идентификатором (`id = 1` или `id = 2`). Они следуют предопределенным маршрутам, запрашивают перемещение в клетки, проверяют их состояние, занимают клетки, обрабатывают их (если необработаны) и освобождают.
-   **Сервер**: Управляет садом, обрабатывает запросы от клиентов, синхронизирует их действия через мьютекс для предотвращения конфликтов, и выводит итоговое состояние сада.

### Поведение и взаимодействие

1.  **Инициализация**:

        -Сервер инициализирует сад, случайно выбирая 10–30% недоступных клеток с помощью функции initialize_grid.

    Каждый клиент генерирует свой маршрут обхода клеток с помощью функции generate_sequence.

2.  **Подключение клиентов**:

    - Клиенты подключаются к серверу, отправляя свой идентификатор (`ID 1` или `ID 2`).
    - Сервер подтверждает подключение, отправляя `OK`.

3.  **Обработка клеток**:

    - Клиент отправляет запрос `MOVE x y` для перемещения в клетку `(x, y)`.
    - Сервер проверяет, свободна ли клетка:
        - Если занята другим садовником, отправляет `WAIT`, и клиент ждет 100 мс перед повторной попыткой.
        - Если свободна, обновляет позицию садовника и отправляет `MOVED`.
    - Клиент запрашивает состояние клетки (`GET_STATE x y`). Сервер возвращает:
        - `INACCESSIBLE` для недоступных клеток.
        - `ACCESSIBLE PROCESSED_BY id` для обработанных клеток.
        - `ACCESSIBLE UNPROCESSED` для необработанных клеток.
    - Если клетка необработана, клиент отправляет `OCCUPY x y`, ждет `P` секунд, затем отправляет `FINISH_PROCESSING x y` и `RELEASE x y`.
    - Если клетка недоступна или уже обработана, клиент пропускает обработку (ждет 1 секунду).

4.  **Завершение**:
    - После обхода всех клеток клиент отправляет `FINISHED` и закрывает соединение.
    - Сервер увеличивает счетчик `finished_gardeners`. Когда оба садовника завершают работу (`finished_gardeners == 2`), сервер выводит итоговое состояние сада.
    - **Сценарий завершения**: В данной реализации клиенты завершают работу после обработки всех клеток, а сервер завершает работу после отключения обоих клиентов. Завершение через внешние сигналы (например, Ctrl+C) не реализовано, но предполагается, что сервер и клиенты могут быть остановлены вручную (например, через `kill`).

### Взаимодействие процессов

-   **Сервер**: Работает как многопоточное приложение. Основной поток принимает подключения клиентов через `accept`. Для каждого клиента создается отдельный поток с помощью `pthread_create`, который обрабатывает все запросы клиента (`handle_client`).
-   **Клиенты**: Работают как отдельные процессы, каждый из которых подключается к серверу через сокет TCP и взаимодействует с ним в однопоточном режиме.
-   **Синхронизация**: Сервер использует мьютекс (`pthread_mutex_t`) для защиты доступа к структуре `grid` и позициям садовников (`gardener_pos`), предотвращая одновременное изменение данных несколькими потоками.

### Указание IP-адресов и портов в командной строке

Реализация поддерживает гибкую настройку сетевых параметров:

-   **Сервер**: Запускается с указанием порта через аргумент командной строки:
    ```bash
    ./server <port>
    ```
    Пример: `./server 8888`.
-   **Клиент**: Запускается с указанием IP-адреса сервера, порта и идентификатора садовника:
    ```bash
    ./client <server_ip> <server_port> <id>
    ```
    Пример: `./client 127.0.0.1 8888 1`.
-   **Скрипт запуска** (`run.sh`): Автоматизирует запуск сервера и двух клиентов с предопределенными параметрами (`127.0.0.1:8888`):
    ```bash
    ./run.sh
    ```
-   **Гибкость**: Параметры `server_ip` и `server_port` задаются через аргументы, что позволяет запускать приложение как на локальном компьютере, так и в распределенной сети, указав соответствующий IP-адрес сервера.

### Использование программных объектов

Для реализации использованы следующие программные объекты и механизмы:

-   **Сокеты TCP** (`sys/socket.h`, `netinet/in.h`): Обеспечивают надежное соединение между сервером и клиентами. Сервер использует `socket`, `bind`, `listen`, `accept` для создания соединений, а клиенты — `socket`, `connect` для подключения.
-   **Многопоточность** (`pthread.h`): Сервер создает отдельный поток для каждого клиента с помощью `pthread_create` и использует `pthread_join` для ожидания завершения клиентов.
-   **Синхронизация** (`pthread_mutex_t`): Мьютекс защищает доступ к общей структуре `grid` и массиву `gardener_pos`, предотвращая гонки данных.
-   **Сетевые функции** (`arpa/inet.h`): Функция `inet_pton` преобразует строковый IP-адрес в бинарный формат для клиента.
-   **Стандартные функции C**: Работа со строками (`sprintf`, `sscanf`, `strcmp`, `strstr`), ввод-вывод (`printf`), управление памятью (`malloc`, `free`).

### Работа в локальном и распределенном режиме

Приложение разработано с учетом работы как на одном компьютере, так и в распределенной сети:

-   **Локальный режим**:
    -   Сервер и клиенты запускаются на одном компьютере с использованием `127.0.0.1` как IP-адреса.
    -   Скрипт `run.sh` демонстрирует запуск в локальном режиме:
        ```bash
        ./server 8888 &
        ./client 127.0.0.1 8888 1 &
        ./client 127.0.0.1 8888 2 &
        ```
-   **Распределенный режим**:
    -   Сервер может быть запущен на одном компьютере, а клиенты — на других, при условии, что указан правильный IP-адрес сервера.
    -   Например, если сервер запущен на компьютере с IP `192.168.1.100`:
        ```bash
        ./server 8888  # на сервере
        ./client 192.168.1.100 8888 1  # на клиентском компьютере 1
        ./client 192.168.1.100 8888 2  # на клиентском компьютере 2
        ```
-   **Тестирование**: Приложение успешно протестировано в локальном режиме на одном компьютере. Для распределенного режима предполагается аналогичная работоспособность при корректной настройке сети.

### Результаты работы программы

Программа была протестирована в локальном режиме с использованием скрипта `run.sh`. Ниже приведены примеры вывода для сервера и клиентов.

### Вывод сервера

```
Итоговое состояние сада:
  0 1 2 3 4
0 1 1 1 1 1
1 X 1 1 1 1
2 2 2 2 X 2
3 2 2 2 2 2
4 2 2 2 2 2
Легенда: X - недоступно, U - необработано, 1 - обработано садовником 1, 2 - обработано садовником 2
```

-   Сервер логирует подключение клиентов и их действия (в отладочной версии, как в предоставленном коде):
    ```
    Received request: ID 1
    Processing ID request for gardener_id: 1
    Received request: ID 2
    Processing ID request for gardener_id: 2
    Received request: MOVE 0 0
    Processing MOVE request for x: 0, y: 0
    ...
    ```
-   После завершения работы обоих садовников сервер выводит итоговое состояние сада и завершает работу.

### Вывод клиента (садовник 1)

```
Садовник 1 пытается переместиться в (0, 0)
Садовник 1 переместился в (0, 0)
Клетка (0, 0) доступна и необработана
Садовник 1 занял клетку (0, 0)
Садовник 1 начал обработку клетки (0, 0)
Садовник 1 завершил обработку клетки (0, 0)
Садовник 1 освободил клетку (0, 0)
...
Садовник 1 завершил свою задачу
```

### Вывод клиента (садовник 2)

```
Садовник 2 пытается переместиться в (4, 4)
Садовник 2 переместился в (4, 4)
Клетка (4, 4) доступна и необработана
Садовник 2 занял клетку (4, 4)
Садовник 2 начал обработку клетки (4, 4)
Садовник 2 завершил обработку клетки (4, 4)
Садовник 2 освободил клетку (4, 4)
...
Садовник 2 завершил свою задачу
```

## 6-7

### 1. Модуль мониторинга (`monitor.c`)

**Ключевые особенности:**

-   Подключается как клиент-наблюдатель, запрашивает состояние сада (`GET_GRID\n`) каждые 10 секунд или по команде `grid`.
-   Использует `poll` для обработки ввода (`grid`, `q`, `exit`) и сообщений сервера.
-   Выводит действия садовников и состояние сада с временными метками.

**Реализация:**

-   Основной цикл с `poll` для асинхронного ввода/вывода.
-   Автоматические и ручные запросы состояния сада.

### 2. Модификации сервера

**Новые функции:**

1. Поддержка монитора через `monitor_sock` и поток `handle_monitor`.
2. Логирование действий садовников в `send_to_monitor`.
3. Отправка состояния сада в `print_grid_to_monitor_only`.

### 3. Модификации клиента

-   Лимит попыток перемещения (`max_attempts = 10`) с пропуском клетки при неудаче.
-   Улучшена обработка ошибок `send`/`recv` с выводом через `perror`.

### Пример работы системы

**Запуск:**

```bash
./server 8888 &
./client 127.0.0.1 8888 1 &
./client 127.0.0.1 8888 2 &
./monitor 127.0.0.1 8888
```

**Вывод монитора:**

```
Подключено к серверу 127.0.0.1:8888
Для запроса состояния сада введите 'grid'. Для отключения монитора введите 'q' или 'exit'
[Thu May 22 04:08:10 2025] Итоговое состояние сада:
  0 1 2 3 4
0 1 1 1 1 1
1 X 1 1 1 1
2 2 2 2 X 2
3 2 2 2 2 2
4 2 2 2 2 2
Легенда: X - недоступно, U - необработано, 1 - обработано садовником 1, 2 - обработано садовником 2
```

## 8

### 1. Модификации сервера

**Новые функции:**

1. Поддержка нескольких мониторов:
    - Список сокетов мониторов (`monitor_socks`) для динамического подключения/отключения.
    - Отправка сообщений всем мониторам через `send_to_monitors`.
2. Обработка идентификатора `MONITOR`:
    - Клиент, отправивший `MONITOR\n`, помечается как монитор.
3. Обработка команды `EXIT`:
    - Удаление сокета монитора из списка при получении `EXIT\n`.

### 2. Модификации клиента

-   Без изменений (идентичен предыдущей версии).

## 9

Все требования на оценку 9 уже реализованы в решении на оценку 8.

## 10

### 1. Модификации сервера

-   Обработка `SIGINT` через `signal_handler` для установки `shutdown_flag`.
-   Функция `send_shutdown_to_all_clients` отправляет `SERVER_SHUTDOWN\n` всем садовникам и мониторам, закрывает их сокеты.
-   Использование `select` с тайм-аутом для асинхронного принятия клиентов.
-   Потоки клиентов создаются с `pthread_detach` для автоматической очистки.
-   Добавлено освобождение ресурсов: закрытие серверного сокета, уничтожение мьютексов.

### 2. Модификации клиента

-   Проверка ответа `SERVER_SHUTDOWN\n` после команд `MOVE`, `GET_STATE`, `OCCUPY`, `RELEASE`, `FINISHED` с корректным завершением.

### 3. Модификации монитора

-   Обработка `SERVER_SHUTDOWN\n` с завершением работы при получении.
